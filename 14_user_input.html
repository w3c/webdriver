<section>
  <h2>Interactions</h2>
  <br>
  The WebDriver API offers two ways of interacting with elements,
  either with a set of low-level "do as I say" actions, or a
  high-level "do as I mean" set of actions. The former are offered to
  allow precise emulation of user input. The latter are offered as a
  convenience to cover the common case, and can conceivably be
  implemented on top of the lower level primitive operations.
  <br>
  Interactions can be used to emulate single input actions as well as
  multiple, simultaneous actions.
  <br>
  <h3>Terms:</h3>
  <br>
  <b>(NOTE: these are by no means the final terms, I needed them to make the prose easier to follow)</b>
  <br>
  <br>
  <b>low-level action:</b> The smallest operation an input device can do. These are used to build chains of actions. Example: keyDown
  <br>
  <b>action chain:</b> A chain of low-level actions
  <br>
  <b>input device:</b> The device from which the inputs will originate. MUST support 'keyboard', 'mouse' and 'touch'
  <br>
  <b>source:</b> The object currently acting on the device. For example, in a 'touch' environment, if two fingers are acting on a touchscreen, you will have two sources of input.
  <br>
  <section>
    <h2 id="interactable">Interactable elements</h2>
    <p>User actions that operate on an element require the element to be interactable. The following conditions must be met for the element to be considered interactable:
    <ul>
      <li>The element MUST be displayed, as defined in <a href="#determining-if-displayed">section 10.1</a>.</li>
      <li>The element MUST NOT be disabled. "Disabled" is defined as:
      <ul>
        <li>If the current document is being processed as an HTML document, the element MUST be considered disabled if it does not support
        the <a href="http://www.w3.org/TR/html401/interact/forms.html#adef-disabled">disabled</a>
        attribute (according to the [[!html51]] spec), or if the
        disabled attribute is set in the case where that attribute is present.</li>
      </ul>
      </li>
    </ul>
    </section>

    <section>
      <h2>Low-Level Actions</h2>
      <br>
      The low level actions provide a mechanism for precisely stating how a user can interact with the browser.
      This is achieved by sending a chain of low-level commands to a single endpoint.
      For example, if you wish to automate a drag and drop action in a browser, you would chain
      the pointerDown, pointerMove, pointerUp and release commands together.
      <br>
      <br>
      The remote end will receive the action chain, execute them, and will return a response to the local end once the entire
      action sequence has been dispatched.
      <br>
      <br>
      <b>NOTE: renaming 'input device' to 'input source' since fingers aren't really devices</b>
      <br>
      The set of actions available to you is depending on the input device. For example, on a keyboard
      you want to have a keyDown action to simulate pressing a specific key on the keyboard, but this
      is not a valid action on a touchscreen, where we care about pointer actions relative to coordinates or webelements.
      <br>
      <p class='note'>
        <a href='http://www.w3.org/TR/DOM-Level-3-Events/#glossary-activation-trigger'>Activation triggers</a> generated by the WebDriver API User SHOULD be indistinguishable from those generated by a real user
        interacting with the browser. In particular, the dispatched events will have the <a href='http://dom.spec.whatwg.org/#dom-event-istrusted'>isTrusted</a> attribute set to true. The most robust way to dispatch these events is by creating them in the browser implementation itself. Sending OS-specific input messages to the browser's window has the disadvantage that the browser being automated may not be properly isolated from a user accidentally modifying input device state; use of an OS-level accessibility API has the disadvantage that the browser's window must be focused, and as a result, multiple tests cannot run in parallel.
      </p>
      <br>
      <section>
        <h2 id="actions-endpoint">Actions Endpoint</h2>
        <section>
          <h2>Sending an Action</h2>
          <table class="simple jsoncommand">
            <tr>
            <th>HTTP Method</th>
              <th>Path Template</th>
              <th>Notes</th>
            </tr>
            <tr>
              <td>POST</td>
              <td>/session/{sessionId}/actions</td>
                <td></td>
            </tr>
          </table>
          <br>
          The 'actions' endpoint expects a list of objects as input. Each object in this list MUST contain the fellowing members:
          <br>
          <br>
          <b>device</b>
          <br>
          <br>
          The "device" member will hold a string value to represent the input device. Implementations MUST support "keyboard", "mouse", and "touch" (<b>TODO: use symbols?</b>), and can be extended for any other input device.
          <br>
          <br>
          <b>id</b>
          <br>
          <br>
          This is a locally-assigned unique identifier. It will be used by the remote end to differentiate dispatched actions. For example, if you have a "touch" action with id "1" to represent one finger actively pressed on a screen, then you can dispatch another "touch" action with id "2" to represent a second finger on a screen, acting simultaneously.
          <br>
          <br>
          <b>actions</b>
          <br>
          <br>
          This holds a list of objects, where each object represents a low-level command. The list order dictates the order in which each command will be dispatched. Each command MUST have a 'name' member, whose value will hold the name of the command. More information on each command is in the action <a href="#action-commands">commands</a> section.
          <br>
          <br>
          So the structure will look as follows:
          <pre>
            [
              {
                "device": "string",
                "id": "string",
                "actions": [
                          { "name": "string: name of action primitive",
                            ... parameters to action commands...
                          },
                ]
              }
            ]
          </pre>
          <br>
          A list of dictionary objects are used so that we may use this same endpoint for <a href="#parallel-actions">parallel actions</a>.
          <br>
          There is one endpoint for all input device's action chains.
        </section>
        <section>
          <h2>Releasing all actions</h2>
          <table class="simple jsoncommand">
            <tr>
            <th>HTTP Method</th>
              <th>Path Template</th>
              <th>Notes</th>
            </tr>
            <tr>
              <td>DELETE</td>
              <td>/session/{sessionId}/actions</td>
                <td></td>
            </tr>
          </table>
          <br>
          <br>
          Use this command to clear all actions that are currently being performed. ALL actions currently being performed MUST be cancelled via pointerCancel if it is a "mouse" or "touch" device or via keyUp if it is a "keyboard" device.
          <br>
          <br>
          <b>NOTE: 'release' as a single command was removed since 'keyUp' and 'pointerUp'/'pointerCancel' exist and 'release' conflates them</b>
        </section>
        <section>
          <h2 id="action-commands">Actions</h2>
          This section describes the objects that are part of the "actions" member of the JSON structure sent to the "actions" endpoint.
          <section>
            <h2>General Actions</h2>
            All input devices MUST implement the following action:
            <br>
            <br>
            <b>pause</b>
            <br>
            <br>
            The "pause" action MUST (<b>TODO: or "may", since we can default to 0 on remote end?</b>) take in a parameter named "duration" which will be the time to wait either in milliseconds or using a symbol. This action is used to indicate a period of time to wait between actions, and will also be used to indicate a period of inaction in <a href="#parallel-actions">parallel action chains</a>.
            <br>
            <br>
            If you wish to use a system specific wait period, please use the following symbols:
              <ul>
                <li><b>"CONTEXT"</b> - wait for contextmenu</li>
                <li><b>"CHAINED_EVENT"</b> - wait period to join related events. For example, this should be used to join events for doubleclicking.</li>
              </ul>
              <br>
              The remote end is responsible for translating these symbols to the platform specific periods.

          </section>
          <section>
            <h2>Keyboard Actions</h2>
            The following are actions that must be implemented for the "keyboard" input source. Their names will be used as the value to the "name" member of the data sent to the 'actions' endpoint. Each actions parameters are additional members to the object that "name" is a member of.
            <br>
            <br>
            <b>keyDown</b>
            <br>
            <br>
            The "keyDown" requires a parameter named "code" whose value will be one of the codes from the <a href="#character-types">character types</a> table. This action will send a "keyDown" event, with the specified key as a target.
            <br>
            <br>
            <b>keyUp</b>
            <br>
            <br>
            The "keyUp" requires a parameter named "code" whose value will be one of the codes from the <a href="#character-types">character types</a> table. This action will send a "keyUp" event, with the specified key as a target.
            <br>
          </section>
          <section>
            <h2>Pointer Actions</h2>
            The following are actions that must be implemented for both "mouse" and "touch" input devices. Any future pointer-based device must implement these actions.
            <br>
            <b>NOTE: conflating mouse and touch causes the pointerMove/pointerDown to events to be confusing and lacks verisimilitude:</b> If you want to tap at element1, then that would mean 'put finger down on element1, remove finger from element1', for a tap, we have to decide if we want to send 'pointerMove, pointerDown, pointerUp' or 'pointerDown, pointerUp'. The latter matches the touch events sent (touchStart,touchEnd), and makes sense for touchscreens because there is no active button state (http://www.w3.org/TR/pointerevents/#glossary) until you dispatch a touchstart. sending a JSON structure with pointerMove, pointerDown, pointerUp for something that gets mapped to touchstart/touchend feels inelegant. We can enforce the following instead:
            if the "device" is mouse, then pointerMove,pointerDown,pointerUp  is sent over the wire
            if the "device" is touch, then pointerDown,pointerUp is sent over the wire.
            if the "device" is anything else (stylus, or other), it will be defined later.

            The ramifications of this proposal would be that pointerDown must accept the parameters that pointerMove does (ie: ELEMENT, etc.).
            <br>
            <br>
            <br>
            <b>pointerMove</b>
            <br>
            <br>
            The "pointerMove" action is used to move the pointer to a specific location on a page. In "mouse" devices, this would dispatch a "mouseMove" event. In "touch" devices, then if there is an active pointerDown action, this will generate a "touchmove" or "pointermove" event. For "touch" devices, pointerMove must not be called before pointerDown, since pointer devices only have move events once they are active on the screen.
            <br>
            When sending a "pointerMove", one of the following parameter sets MUST be used:
            <ul>
              <li><b>"ELEMENT"</b> - "ELEMENT" will hold a WebElement's id, and this will dispatch the event to the center of that element, unless the following set of parameters is also included:</li>
              <ul>
                <li><b>"x"</b> - Integer, the x-coordinate relative to the top-left corner of the target WebElement. If this is not specifed, the midpoint of the width is used</li>
                <li><b>"y"</b> - Integer, the y-coordinate relative to the top-left corner of the target WebElement. If this is not specifed, the midpoint of the height is used</li>
              </ul>
              <ul>
                <li><b>"x" and "y"</b> - Integers, the coordinates relative to the top-left corner of the <b>TODO: viewport, or top-left of root document?</b>.
              </ul>
            </ul>
            <br>
            <br>
            <b>pointerDown</b>
            <br>
            <br>
            The "pointerDown" action is used to start an interaction on the page. In "mouse" devices, this would mean "mouseDown", in "touch" devices, this would mean "touchstart" or "pointerdown".
            <br>
            <br>
            For "touch" devices, the following parameters must be passed:
            <ul>
              <li><b>"ELEMENT"</b> - "ELEMENT" will hold a WebElement's id, and this will dispatch the event to the center of that element, unless the following optional set of parameters is also included:</li>
              <ul>
                <li><b>"x"</b> - Integer, the x-coordinate relative to the top-left corner of the target WebElement. If this is not specifed, the midpoint of the width is used</li>
                <li><b>"y"</b> - Integer, the y-coordinate relative to the top-left corner of the target WebElement. If this is not specifed, the midpoint of the height is used</li>
              </ul>
            </ul>
            <br>
            <br>
            For "mouse" devices, the following parameter must be passed:
            <ul>
              <li><b>"BUTTON"</b> - "BUTTON" will hold a value describing which mouse button should be depressed.<b>TODO: link to button chart</b></li>
            </ul>
            <br>
            <br>
            <b>pointerUp</b>
            <br>
            <br>
            The "pointerUp" action is used to start an interaction on the page. In "mouse" devices, this would mean "mouseUp", in "touch" devices, this would mean dispatching an event like "touchend" or "pointerup".
            <br>
            <br>
            Takes no parameters
            <br>
            <br>
            <b>pointerCancel</b>
            <br>
            <br>
            The "pointerMove" action is used to cancel an active pointer on the page. In "mouse" devices, this would mean "mouseUp", in "touch" devices, it implies cancelling the current action if possible by dispatching an event like "touchcancel" or "pointercancel".
          </section>
          <section>
            <h2 id='parallel-actions'>Parallel Actions</h2>
            Parallel actions are those that have more than one action acting simultaneously on the browser. An example of this is using multiple fingers to operate on a tablet screen at the same time.
            <br>
            <br>
            <b>NOTE: I'm using 'batches' as 'tick' sounds odd in this context</b>
            <br>
            Dispatching a parallel action also uses the <a href="#actions-endpoint">actions endpoint</a>. In order to send a parallel action, append multiple dictionaries to the list of dictionary objects. Each dictionary will hold all the actions from one input source. The list of actions each dictionary contains will be executed together in batches, by stepping through each input source's action list in order and executing each step simultaneously.
            <br>
            <br>
            The best way to understand this is through an example. Imagine we have two fingers acting on a touchscreen. One finger will press down on element1 at the same moment that another finger presses down on element2. Once these actions are done, the first finger will wait 5 seconds while the other finger moves to element3. Then both fingers release from the touchscreen.
            <br>
            <br>
            To execute these actions, we must send the "actions" endpoint two dictionary objects in the JSON list of dictionaries, one fore each finger. We must use the "id" key of each object to uniquely identify each finger. The "actions" key will hold all the actions the input source will take.
            <br>
            <br>
            The JSON for this set of actions is as follows:
            <pre>
              [
                {
                  "device": "touch",
                  "id": "1",
                  "actions": [
                            { "name": "pointerDown",
                              "ELEMENT": "element1"
                            },
                            { "name": "pause",
                              "duration": 0
                            },
                            { "name": "pointerUp"
                            }
                  ]
                },
                {
                  "device": "touch",
                  "id": "2",
                  "actions": [
                            { "name": "pointerDown",
                              "ELEMENT": "element2"
                            },
                            { "name": "pointerMove",
                              "ELEMENT": "element3"
                            },
                            { "name": "pointerUp"
                            }
                  ]
                }
              ]
            </pre>
            <br>
            <br>
            When the remote end receives this, it will look at each input source's action lists. It will dispatch the first action of each source together, then the second actions together, and lastly, the final actions together.
            <br>
            <br>
            The diagram below displays when each action gets executed. "Source 1" is the first finger, and "source 2" is the second.
            <br>
            <img src="svgs/note1actions.svg">
            <br>
            <br>
            There is no limit to the number of input sources, and there is no restriction regarding the length of each input's action list. Meaning, there is no requirement that all action lists have to be the same length. It is possible for one input source's action list may have more actions than another. As an example, imagine having two fingers on a touchscreen. The first finger will press on element1 while the second presses on element2, then the first will release the touchscreen while the second finger moves to element3, and finally the second finger releases from the touchscreen. In this case, the action list for the first finger contains 2 actions (pointerDown, pointerUp), and the action list for the second finger contains 3 (pointerDown, pointerMove, pointerUp). In this case, the JSON will look like this:
            <pre>
              [
                {
                  "device": "touch",
                  "id": "1",
                  "actions": [
                            { "name": "pointerDown",
                              "ELEMENT": "element1"
                            },
                            { "name": "pointerUp"
                            }
                  ]
                },
                {
                  "device": "touch",
                  "id": "2",
                  "actions": [
                            { "name": "pointerDown",
                              "ELEMENT": "element2"
                            },
                            { "name": "pointerMove",
                              "ELEMENT": "element3"
                            },
                            { "name": "pointerUp"
                            }
                  ]
                }
              ]
            </pre>
            And the execution of each action will be done as follows:
            <br>
            <img src="svgs/note4actions.svg">
            <br>
            <br>
            Specific timing for the actions can also be expressed. The "pause" action can be used to either a) indicate a specific amount of time an input source must wait, or b) can be used to signify that the current input source must wait until all other actions in the batch are completed. For the former case, the current batch being executed must wait for the longest pause to complete. For example, in this diagram:
            <br>
            <br>
            <img src="svgs/note2actions.svg">
            <br>
            <br>
            The remote end will dispatch the pointerDown actions in the first batch. In the second batch, since source 1 declares a pause of 5 seconds, the remote end will dispatch the pointerUp event for source 2, and will wait 5 seconds before moving on to executing the third batch.
            <br>
            <br>
            In the event that one batch contains multiple pause durations, the remote end will wait the maximum duration before moving on to executing the next batch.
            <br>
            <br>
            As noted before, "pause" can be used to signify inaction during a batch. If "pause" is declared without a time period, then the input source will not have any actions executed in the containing batch. As an example:
            <br>
            <br>
            <img src="svgs/note3actions.svg">
            <br>
            <br>
            During batch 2, source 1 will have its pointerMove action dispatched, while source 2 will do nothing.
         </section>
      </section> <!-- low-level wire protocol commands -->

    <section>
      <h2>High Level Commands</h2>
        <p>These higher level commands SHOULD be built on top of the low level commands, and implement a user friendly way of interacting with a page in a way that models common user expectations.

        <section>
          <h2 id='high-level-click'>Clicking</a></h2>
          <dl class="idl" title="partial interface WebElement">
            <dt>void click()</dt>
            <dd>Click in the middle of the <a>WebElement</a> instance. The middle of the element is defined as the middle of the box returned by
            calling <code><a
              href="http://www.w3.org/TR/cssom-view/#the-getclientrects()-and-getboundingclientrect()-methods">getBoundingClientRect</a></code>
            on the underlying document Element, according to the [[!CSSOM-VIEW]] spec. If
            the element is outside the <a
              href="http://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
            (according to the [[!CSS21]] spec), the implementation SHOULD bring the
            element into view first. The implementation MAY invoke <code>scrollIntoView</code> on
            the underlying document Element. The element MUST be <a
              href="#determining-if-displayed">displayed</a>. See the note below for when the element is obscured by another element.
            Exceptions:
            <ul>
              <li>Links (A elements): Clicking happens in the middle of the first
                <a href="#determining-if-displayed">displayed</a> bounding client rectangle. This is to overcome overflowing links where the middle of the bounding client rectangle does not actually fall on a clickable part of the link.</li>
              <li>SELECT elements without the &quot;multiple&quot; attribute set.
                Clicking on the select element SHOULD open the drop down menu. The next
                click, on any element, MUST close this menu.</li>
              <li>Clicking directly on an OPTION element (without clicking on the
                parent SELECT element previously) MUST open a selection menu, as if the
                SELECT option was clicked first, then click on the OPTION before finally
                closing the SELECT element's menu. The SELECT menu MUST be closed
                once the action is complete.</li>
            </ul>
            <p>The possible errors for this command:
            <ul>
              <li><code><a href="#status-stale-element-reference">stale element reference</a></code> if the given element is no longer in the <a href="http://dom.spec.whatwg.org/#in-a-document">document</a>.</li>
              <li><code><a href="#status-element-not-visible">element not visible</a></code> if the element is hidden and thus cannot be interacted with.</li>
              <li><code><a href="#status-move-target-out-of-bounds">move target out of bounds</a></code> if the element cannot be scrolled into view.</li>
            </ul>
            <p>This command MUST use either the mouse or touch mechanisms for
              emulating the user input. In the case where the browser being automated
              supports only mouse input or both mouse and touch input, the low-level
              mouse mechanisms MUST be used. If the browser only supports touch input,
              the low level touch inputs MUST be used.</p>
            </dd>
          </dl>
          <p class="note">As the goal is to emulate users as closely as possible, the
            implementation SHOULD NOT allow clicking on elements that are obscured by
            other elements. If the implementation forbids clicking on obscured elements,
            an <code><a href="#status-element-not-visible">element not visible</a></code> response MUST be returned and this SHOULD have an
            explantory message explaining the reason. The implementation SHOULD try to
            scroll the element into view, but in case it is fully obscured, it SHOULD
            NOT be clickable.<!--TODO: add details of interactable'--></p>
        </section>
        <section>
          <h2>Touch</h2>
          <p>This section defines the low level commands used when manipulating touch-enabled devices. These are the building blocks of touch interaction chains.</p>
          <!--<p>NOTE: would like to add pressure/tilt, but that isn't in Touch Events (http://www.w3.org/TR/touch-events/), will have to wait for Pointer Event adoption</p>-->
          <table class="simple">
            <tr><td>Capability Name</td><td>Type</td></tr>
            <tr><td><span id="capability-touchEnabled">touchEnabled</span></td><td>boolean</td></tr>
          </table>
          <br>
          <br>
          <dl class='idl' title='partial interface WebElement'>
            <!-- Tap -->
            <dt>void tap ()</dt>
            <dd>Tap in the middle of the <a>WebElement</a>. The middle of the element is defined as the middle of the box returned by
              calling <code><a
                href="http://www.w3.org/TR/cssom-view/#the-getclientrects()-and-getboundingclientrect()-methods">getBoundingClientRect</a></code>
              on the underlying document Element, according to the [[!CSSOM-VIEW]] spec. If
              the element is outside the <a
                href="http://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
              (according to the [[!CSS21]] spec), the implementation SHOULD bring the
              element into view first. The implementation MAY invoke <code>scrollIntoView</code> on
              the underlying document Element.
              Exceptions:
              <ul>
                <li>Links (A elements): Clicking happens in the middle of the first
                  <a href="#determining-if-displayed">displayed</a> bounding client rectangle. This is to overcome overflowing links where the middle of the bounding client rectangle does not actually fall on a clickable part of the link.</li>
                <li>SELECT elements without the &quot;multiple&quot; attribute set.
                  Clicking on the select element SHOULD open the drop down menu. The next
                  click, on any element, MUST close this menu.</li>
                <li>Clicking directly on an OPTION element (without clicking on the
                  parent SELECT element previously) MUST open a selection menu, as if the
                  SELECT option was clicked first, then click on the OPTION before finally
                  closing the SELECT element's menu. The SELECT menu MUST be closed
                  once the action is complete.</li>
              </ul>
              <p>The possible errors for this command:
              <ul>
                <li><code><a href="#status-stale-element-reference">stale element reference</a></code> if the given element is no longer in the <a href="http://dom.spec.whatwg.org/#in-a-document">document</a>.</li>
                <li><code><a href="#status-move-target-out-of-bounds">move target out of bounds</a></code> if the element cannot be scrolled into view.</li>
              </ul>
            </dd>
          </dl>
        </section>
      <section>
        <h2 id='typing_keys'>Typing keys</h2>
        <p>A requirement for key-based interaction with an element is that it is
          <a href="#interactable">interactable</a>. Typing into an element is permitted if one of the following conditions is met:
            <ul>
              <li>The element is <a href="http://dev.w3.org/html5/spec/editing.html#focus">focusable</a> as defined in the editing section of the [[!html51]] spec.</li>
              <li>The element is allowed to be the <code><a href='http://www.w3.org/html/wg/drafts/html/master/editing.html#dom-document-activeelement'>activeElement</a></code>. In
              addition to focusable elements, this allows typing to the <code>BODY</code> element.</li>
              <li>In an HTML document, the element is <a href="http://dev.w3.org/html5/spec/editing.html#attr-contenteditable">editable</a> as a result of having its <code>contentEditable</code> attribute set or the containing document is in <code>designMode</code>.</li>
              <li>The underlying browser implementation would allow keyboard input to
              directed to the element (eg. an HTML document with a DIV marked as being
              contentEditable)</li>
            </ul>
        <p>Prior to any keyboard interaction, an attempt to shift focus to the
        element MUST be attempted if the element does not currently have the focus. This is the case if one of the following
        holds:
        <ul>
          <li>The element is not already the document's <code><a href='http://www.w3.org/html/wg/drafts/html/master/editing.html#dom-document-activeelement'>activeElement</a></code>.</li>
          <li>The owner document of the element to be interacted with is not the focused document.</li>
        </ul>
        <p>In case focusing is needed, the implementation MUST follow the <a href="http://dev.w3.org/html5/spec/editing.html#focus-management"><b>focusing steps</b></a> as described in the focus management section of the [[!html51]] spec. The focus MUST NOT leave the element at the end of the interaction, other than as a result of the interaction itself (i.e. when the tab key is sent).
        </p>
        <dl class="idl" title="partial interface WebElement">
          <dt>void clear()</dt>
          <dd>Clears the value of the element.</dd>
          <dt>void sendKeys()</dt>
          <dd>
            <dl class='parameters'>
              <dt>DOMString value</dt>
              <dd>The characters that will be typed in the <a>WebElement</a></dd>
            </dl>
            <p>Sends a sequence of keyboard events representing the keys in the value parameter.
            <p>Caret positioning: If focusing was needed, after following the focusing steps, the caret MUST be positioned at the end of the text currently in the element. At the end of the interaction, the caret MUST be positioned at the end of the typed text sequence, unless the keys sent position it otherwise (e.g. using the LEFT key).</p>
            <p>There are four different types of keys that are emulated:
            <ul>
              <li>Character literals - lower-case symbols.</li>
              <li>Uppercase letters and symbols requiring the SHIFT key for typing.</li>
              <li>Modifier keys</li>
              <li>Special keys</li>
            </ul>The rest of this section details the values used to represent the different keys, as well as the expected behaviour for each key type.</dd>
        </dl>
        <p>When emulating user input, the implementation MUST generate
        the same sequence of events that would have been produced if a real user was
        sitting in front of the keyboard and typing the sequence of characters. In
        cases where there is more than one way to type this sequence, the
        implementation MUST choose one of the valid ways. For example, typing <code>AB</code> may be achieved by:
        <ul>
          <li>Holding down the Shift key</li>
          <li>Pressing the letter 'a'</li>
          <li>Pressing the letter 'b'</li>
          <li>Releasing the Shift key</li>
        </ul>
        Alternatively, it can be achieved by:
        <ul>
          <li>Holding down the Shift key</li>
          <li>Pressing the letter 'a'</li>
          <li>Releasing the Shift key</li>
          <li>Holding down the Shift key</li>
          <li>Pressing the letter 'b'</li>
          <li>Releasing the Shift key</li>
        </ul>
        <p>Or by simply turning on the CAPS LOCK first.</p>
        <p>
        The implementation MAY use the following algorithm to generate the events.
        If the implementation is using a different algorithm, it MUST adhere to the
        requirements listed below.
        <p>For each key, <var>key</var> in <var>value</var>, do
        <ol>
          <li>If <var>key</var> is a lower-case symbol:
          <ol>
            <li>If the Shift key is not pressed:
              <ol>
                <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events with
                <var>key</var> as
                the character to emulate</li>
              </ol>
            </li>
            <li>else (The Shift key is pressed)
              <ol>
                <li>let <var>uppercaseKey</var> be the upper-case character matching
                <var>key</var></li>
                <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events with
                <var>uppercaseKey</var> as the character to emulate</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Else if <var>key</var> is an upper-case symbol:
          <ol>
            <li>If the Shift key is not pressed:
            <ol>
              <li>Generate a <code>keydown</code> event of the Shift key.
              <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events with
              <var>key</var> as
              the character to emulate</li>
              <li>Generate a <code>keyup</code> event of the Shift key.
            </ol>
          </li>
          <li>else (The Shift key is pressed)
            <ol>
              <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events with
              <var>key</var> as the character to emulate</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Else if <var>key</var> represents a modifier key:
        <ol>
          <li>let <var>modifier</var> be the modifier key represented by
          <var>key</var></li>
          <li>If <var>modifier</var> is currently held down:
        <ol>
      <li>Generate a <code>keyup</code> event of <var>modifier</var></li>
    </ol>
  </li>
  <li>Else:
    <ol>
      <li>Generate a <code>keydown</code> event of <var>modifier</var></li>
    </ol>
  </li>
  <li>Maintain this key state and use it to modify the input until it is pressed again.</li>
</ol>
      </li>
      <li>Else if <var>key</var> represents the NULL key:
      <ol>
        <li>Generate <code>keyup</code> events of all modifier keys currently held
        down.</li>
        <li>All modifier keys are now assumed to be released.</li>
      </ol>
      </li>
      <li>Else if <var>key</var> represents a special key:
      <ol>
        <li>Translate <var>key</var> to the special key it represents</li>
        <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events for the special key.</li>
      </ol>
      </li>
    </ol>
    <p>Once keyboard input is complete, an implicit <var>NULL</var> key is sent unless the
    final character is the <var>NULL</var> key.</p>
    <p> <!-- Pseudo-code --></p>
    <p>Any implementation MUST comply with these requirements:
    <ul>
      <li>For uppercase letters and symbols that require the Shift key to be
      pressed, there are two options:
      <ul>
        <li>A single Shift <code>keydown</code> event is generated before the entire
        sequence of uppercase letters.</li>
        <li>Before each such letter or symbol, a Shift <code>keydown</code> event is
        generated. After each letter or symbol, a Shift <code>keyup</code> event is
        generated.</li>
      </ul></li>
      <li>A user-specified Shift press implies capitalization of all following
      characters.</li>
      <li>If a user-specified Shift press precedes uppercase letters and
      symbols, a second Shift <code>keydown</code> event MUST NOT be generated. In that
      case, a Shift <code>keyup</code> event MUST NOT be generated implicitly by the
      implementation.</li>
      <li>The <var>NULL</var> key releases all currently held down modifier keys.</li>
      <li>The state of all modifier keys must be reset at the end of each
      <code>sendKeys</code> call and the appropriate <code>keyup</code> events
      generated</li>
    </ul>
    <p> <!-- Algorithm paragraph --></p>
    <h3 id="character-types">Character types</h3>
    <p>The <var>value</var> parameter contains a mix of printable
    characters and pressable keys that aren't text. Pressable keys that aren't
    text are stored in the Unicode PUA (Private Use Area) code points,
    0xE000-0xF8FF. The following table describes the mapping between PUA and
    key:
    <table class="simple">
      <tr>
        <th>Key</th>
        <th>Code</th>
        <th>Type</th>
      </tr>
      <tr><td>NULL</td><td>\uE000</td><td>NULL</td></tr>
      <tr><td>CANCEL</td><td>\uE001</td><td>Special key</td></tr>
      <tr><td>HELP</td><td>\uE002</td><td>Special key</td></tr>
      <tr><td>BACK_SPACE</td><td>\uE003</td><td>Special key</td></tr>
      <tr><td>TAB</td><td>\uE004</td><td>Special key</td></tr>
      <tr><td>CLEAR</td><td>\uE005</td><td>Special key</td></tr>
      <tr><td>RETURN</td><td>\uE006</td><td>Special key</td></tr>
      <tr><td>ENTER</td><td>\uE007</td><td>Special key</td></tr>
      <tr><td>SHIFT</td><td>\uE008</td><td>Modifier</td></tr>
      <tr><td>CONTROL</td><td>\uE009</td><td>Modifier</td></tr>
      <tr><td>ALT</td><td>\uE00A</td><td>Modifier</td></tr>
      <tr><td>PAUSE</td><td>\uE00B</td><td>Special key</td></tr>
      <tr><td>ESCAPE</td><td>\uE00C</td><td>Special key</td></tr>
      <tr><td>SPACE</td><td>\uE00D</td><td>Special key</td></tr>
      <tr><td>PAGE_UP</td><td>\uE00E</td><td>Special key</td></tr>
      <tr><td>PAGE_DOWN</td><td>\uE00F</td><td>Special key</td></tr>
      <tr><td>END</td><td>\uE010</td><td>Special key</td></tr>
      <tr><td>HOME</td><td>\uE011</td><td>Special key</td></tr>
      <tr><td>ARROW_LEFT</td><td>\uE012</td><td>Special key</td></tr>
      <tr><td>ARROW_UP</td><td>\uE013</td><td>Special key</td></tr>
      <tr><td>ARROW_RIGHT</td><td>\uE014</td><td>Special key</td></tr>
      <tr><td>ARROW_DOWN</td><td>\uE015</td><td>Special key</td></tr>
      <tr><td>INSERT</td><td>\uE016</td><td>Special key</td></tr>
      <tr><td>DELETE</td><td>\uE017</td><td>Special key</td></tr>
      <tr><td>SEMICOLON</td><td>\uE018</td><td>Special key</td></tr>
      <tr><td>EQUALS</td><td>\uE019</td><td>Special key</td></tr>
      <tr><td>NUMPAD0</td><td>\uE01A</td><td>Special key</td></tr>
      <tr><td>NUMPAD1</td><td>\uE01B</td><td>Special key</td></tr>
      <tr><td>NUMPAD2</td><td>\uE01C</td><td>Special key</td></tr>
      <tr><td>NUMPAD3</td><td>\uE01D</td><td>Special key</td></tr>
      <tr><td>NUMPAD4</td><td>\uE01E</td><td>Special key</td></tr>
      <tr><td>NUMPAD5</td><td>\uE01F</td><td>Special key</td></tr>
      <tr><td>NUMPAD6</td><td>\uE020</td><td>Special key</td></tr>
      <tr><td>NUMPAD7</td><td>\uE021</td><td>Special key</td></tr>
      <tr><td>NUMPAD8</td><td>\uE022</td><td>Special key</td></tr>
      <tr><td>NUMPAD9</td><td>\uE023</td><td>Special key</td></tr>
      <tr><td>MULTIPLY</td><td>\uE024</td><td>Special key</td></tr>
      <tr><td>ADD</td><td>\uE025</td><td>Special key</td></tr>
      <tr><td>SEPARATOR</td><td>\uE026</td><td>Special key</td></tr>
      <tr><td>SUBTRACT</td><td>\uE027</td><td>Special key</td></tr>
      <tr><td>DECIMAL</td><td>\uE028</td><td>Special key</td></tr>
      <tr><td>DIVIDE</td><td>\uE029</td><td>Special key</td></tr>
      <tr><td>F1</td><td>\uE031</td><td>Special key</td></tr>
      <tr><td>F2</td><td>\uE032</td><td>Special key</td></tr>
      <tr><td>F3</td><td>\uE033</td><td>Special key</td></tr>
      <tr><td>F4</td><td>\uE034</td><td>Special key</td></tr>
      <tr><td>F5</td><td>\uE035</td><td>Special key</td></tr>
      <tr><td>F6</td><td>\uE036</td><td>Special key</td></tr>
      <tr><td>F7</td><td>\uE037</td><td>Special key</td></tr>
      <tr><td>F8</td><td>\uE038</td><td>Special key</td></tr>
      <tr><td>F9</td><td>\uE039</td><td>Special key</td></tr>
      <tr><td>F10</td><td>\uE03A</td><td>Special key</td></tr>
      <tr><td>F11</td><td>\uE03B</td><td>Special key</td></tr>
      <tr><td>F12</td><td>\uE03C</td><td>Special key</td></tr>
      <tr><td>META</td><td>\uE03D</td><td>Special key</td></tr>
      <tr><td>COMMAND</td><td>\uE03D</td><td>Special key</td></tr>
      <tr><td>ZENKAKU_HANKAKU</td><td>\uE040</td><td>Special key</td></tr>
    </table>
    <p>The keys considered upper-case symbols are either defined by the current keyboard locale or are derived from the US 104 keys Microsoft Windows keyboard layout, which are:
    <ul>
      <li>A - Z</li>
      <li>!$^*()+{}:?|~@#%_\" &amp; &lt; &gt;</li>
    </ul>
    <p>When the user input is emulated natively (see note below), the implementation SHOULD use the current keyboard locale to determine which symbols are upper case. In all other cases, the implementation MUST use the US 104 key Microsoft Windows keyboard layout to determine those symbols.</p>
    <p>The state of the physical keyboard MUST NOT affect emulated user input.</p>
    <h3>Internationalized input</h3>
    <p>Non-latin symbols: TBD</p>
    <p>Complex scripts using Input Method Editor (IME): TBD</p>
    </section> <!-- typing -->
  </section>
  </section>
    </section> <!-- high-level APIs -->
</section>
